# Dataset used: Microsoft Malware Classification Challenge (BIG 2015)
# Citation: http://arxiv.org/abs/1802.10135
# Alessandro Panconesi, Marian, Will Cukierski, WWW BIG - Cup Committee. (2015).
# Microsoft Malware Classification Challenge (BIG 2015). Kaggle. https://kaggle.com/competitions/malware-classification

# Static Malware Feature Selection for .asm/.bytes files

import os
import pandas as pd
import math
import glob

def calculate_entropy(data):
    if not data:
        return 0
    entropy = 0
    for byte in range(256):
        p_x = float(data.count(chr(byte))) / len(data)
        if p_x > 0:
            entropy += - p_x * math.log2(p_x)
    return entropy

def read_file(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
            content = file.read()
        return content
    except FileNotFoundError:
        print(f"File not found: {file_path}")
        return None

def extract_asm_features(file_path, labels_df):
    content = read_file(file_path)
    if content is None:
        return None

    file_name = os.path.basename(file_path)
    file_id = os.path.splitext(file_name)[0]

    keywords = ['mov', 'call', 'push', 'pop', 'xor', 'sub', 'add', 'jmp'] # common x86 assembly instructions
    keyword_counts = {keyword: content.lower().count(keyword) for keyword in keywords}

    file_size = os.path.getsize(file_path)
    asm_entropy = calculate_entropy(content)

    # Additional features
    sections = ['.text', '.data', '.bss', '.rodata']
    section_presence = {section + '_present': int(section in content.lower()) for section in sections}
    section_counts = {section + '_count': content.lower().count(section) for section in sections}
    
    proc_count = content.lower().count('proc ')
    
    comment_count = content.count(';')

    label_row = labels_df[labels_df['Id'] == file_id]
    if not label_row.empty:
        label = 'malicious' if label_row.iloc[0]['Class'] in range(1, 10) else 'benign'
        file_class = label_row.iloc[0]['Class']
    else:
        label = 'unknown'
        file_class = None

    features = {
        'hash_value': file_id, # unique hash value for each specific .asm/.BYTES file
        **keyword_counts, # counts of instructions such as 'mov', 'add', etc.
        'asm_file_size': file_size, # file size of the .asm file
        'asm_entropy': asm_entropy, # randomness/unpredictability of the contents of a .asm file
        'num_bytes': None, # total bytes within the corresponding .BYTES file
        'proc_count': proc_count, # counts of proc (procedure/functions) in the .asm file
        **section_presence, # binary features indicating presence of each section '.text', '.data', '.bss', '.rodata'
        **section_counts, # counts of each section '.text', '.data', '.bss', '.rodata'
        'comment_count': comment_count, # counts of comments
        'class': None, # family of malware (1 - 9)
        'label': None # malicious or benign (if it has a class label, it is malcious by default)
        # 'class' and 'label' will be the last columns
    }

    return features

def add_bytes_info(features, bytes_file_path):
    bytes_content = read_file(bytes_file_path)
    if bytes_content is None:
        return None

    num_bytes = len(bytes_content)
    features['num_bytes'] = num_bytes

    return features

try:
    labels_df = pd.read_csv(r'C:\Users\Leo\Desktop\Senior Design II\ml_models\malware_classification\data\trainLabels.csv')
except FileNotFoundError:
    print("trainLabels.csv not found. Make sure it's in the same directory as this script.")
    labels_df = pd.DataFrame()

data_directory = r'C:\Users\Leo\Desktop\Senior Design II\ml_models\malware_classification\raw'
asm_file_paths = glob.glob(os.path.join(data_directory, '*.asm'))

data = []

for asm_file_path in asm_file_paths:
    features = extract_asm_features(asm_file_path, labels_df)
    if features is not None:
        bytes_file_path = asm_file_path.replace('.asm', '.bytes')
        if os.path.exists(bytes_file_path):
            features = add_bytes_info(features, bytes_file_path)
            if features is not None:
                label_row = labels_df[labels_df['Id'] == features['hash_value']]
                if not label_row.empty:
                    features['class'] = label_row.iloc[0]['Class']
                    features['label'] = 'malicious' if features['class'] in range(1, 10) else 'benign'
                data.append(features)
        else:
            print(f"Corresponding .bytes file not found: {bytes_file_path}")

if data:
    df = pd.DataFrame(data)
    df.to_csv('malware_dataset.csv', index=True, index_label='index')
    print('.csv dataset succesfully created!')
else:
    print("\nNo valid data to save.")